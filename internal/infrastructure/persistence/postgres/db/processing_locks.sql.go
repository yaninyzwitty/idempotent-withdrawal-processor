// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: processing_locks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireProcessingLock = `-- name: AcquireProcessingLock :one
INSERT INTO processing_locks (withdrawal_id, locked_by, locked_at, expires_at)
VALUES ($1, $2, NOW(), NOW() + INTERVAL '1 second' * $3)
ON CONFLICT (withdrawal_id) DO UPDATE
SET locked_by = EXCLUDED.locked_by,
    locked_at = EXCLUDED.locked_at,
    expires_at = EXCLUDED.expires_at
WHERE processing_locks.expires_at <= NOW()
RETURNING withdrawal_id, locked_by, locked_at, expires_at
`

type AcquireProcessingLockParams struct {
	WithdrawalID string      `json:"withdrawal_id"`
	LockedBy     pgtype.Text `json:"locked_by"`
	Column3      interface{} `json:"column_3"`
}

func (q *Queries) AcquireProcessingLock(ctx context.Context, arg AcquireProcessingLockParams) (ProcessingLock, error) {
	row := q.db.QueryRow(ctx, acquireProcessingLock, arg.WithdrawalID, arg.LockedBy, arg.Column3)
	var i ProcessingLock
	err := row.Scan(
		&i.WithdrawalID,
		&i.LockedBy,
		&i.LockedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteExpiredProcessingLocks = `-- name: DeleteExpiredProcessingLocks :exec
DELETE FROM processing_locks WHERE expires_at <= NOW()
`

func (q *Queries) DeleteExpiredProcessingLocks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredProcessingLocks)
	return err
}

const extendProcessingLock = `-- name: ExtendProcessingLock :one
UPDATE processing_locks
SET expires_at = expires_at + INTERVAL '1 second' * $3
WHERE withdrawal_id = $1 AND locked_by = $2 AND expires_at > NOW()
RETURNING withdrawal_id, locked_by, locked_at, expires_at
`

type ExtendProcessingLockParams struct {
	WithdrawalID string      `json:"withdrawal_id"`
	LockedBy     pgtype.Text `json:"locked_by"`
	Column3      interface{} `json:"column_3"`
}

func (q *Queries) ExtendProcessingLock(ctx context.Context, arg ExtendProcessingLockParams) (ProcessingLock, error) {
	row := q.db.QueryRow(ctx, extendProcessingLock, arg.WithdrawalID, arg.LockedBy, arg.Column3)
	var i ProcessingLock
	err := row.Scan(
		&i.WithdrawalID,
		&i.LockedBy,
		&i.LockedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const isProcessingLocked = `-- name: IsProcessingLocked :one
SELECT EXISTS (
    SELECT 1 FROM processing_locks 
    WHERE withdrawal_id = $1 AND expires_at > NOW()
)
`

func (q *Queries) IsProcessingLocked(ctx context.Context, withdrawalID string) (bool, error) {
	row := q.db.QueryRow(ctx, isProcessingLocked, withdrawalID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const releaseProcessingLock = `-- name: ReleaseProcessingLock :exec
DELETE FROM processing_locks WHERE withdrawal_id = $1 AND locked_by = $2
`

type ReleaseProcessingLockParams struct {
	WithdrawalID string      `json:"withdrawal_id"`
	LockedBy     pgtype.Text `json:"locked_by"`
}

func (q *Queries) ReleaseProcessingLock(ctx context.Context, arg ReleaseProcessingLockParams) error {
	_, err := q.db.Exec(ctx, releaseProcessingLock, arg.WithdrawalID, arg.LockedBy)
	return err
}
