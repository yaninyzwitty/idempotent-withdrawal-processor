// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: withdrawals.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWithdrawal = `-- name: CreateWithdrawal :one
INSERT INTO withdrawals (
    id, idempotency_key, user_id, asset, amount, destination_addr, network,
    status, retry_count, max_retries, error_message, tx_hash,
    created_at, updated_at, processed_at, processing_version
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
) RETURNING id, idempotency_key, user_id, asset, amount, destination_addr, network, status, retry_count, max_retries, error_message, tx_hash, created_at, updated_at, processed_at, processing_version
`

type CreateWithdrawalParams struct {
	ID                string             `json:"id"`
	IdempotencyKey    string             `json:"idempotency_key"`
	UserID            string             `json:"user_id"`
	Asset             string             `json:"asset"`
	Amount            string             `json:"amount"`
	DestinationAddr   string             `json:"destination_addr"`
	Network           string             `json:"network"`
	Status            string             `json:"status"`
	RetryCount        int32              `json:"retry_count"`
	MaxRetries        int32              `json:"max_retries"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	TxHash            pgtype.Text        `json:"tx_hash"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt       pgtype.Timestamptz `json:"processed_at"`
	ProcessingVersion int64              `json:"processing_version"`
}

func (q *Queries) CreateWithdrawal(ctx context.Context, arg CreateWithdrawalParams) (Withdrawal, error) {
	row := q.db.QueryRow(ctx, createWithdrawal,
		arg.ID,
		arg.IdempotencyKey,
		arg.UserID,
		arg.Asset,
		arg.Amount,
		arg.DestinationAddr,
		arg.Network,
		arg.Status,
		arg.RetryCount,
		arg.MaxRetries,
		arg.ErrorMessage,
		arg.TxHash,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProcessedAt,
		arg.ProcessingVersion,
	)
	var i Withdrawal
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.UserID,
		&i.Asset,
		&i.Amount,
		&i.DestinationAddr,
		&i.Network,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.TxHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.ProcessingVersion,
	)
	return i, err
}

const getPendingWithdrawals = `-- name: GetPendingWithdrawals :many
SELECT id, idempotency_key, user_id, asset, amount, destination_addr, network, status, retry_count, max_retries, error_message, tx_hash, created_at, updated_at, processed_at, processing_version FROM withdrawals WHERE status IN ('PENDING', 'RETRYING') ORDER BY created_at ASC LIMIT $1
`

func (q *Queries) GetPendingWithdrawals(ctx context.Context, limit int32) ([]Withdrawal, error) {
	rows, err := q.db.Query(ctx, getPendingWithdrawals, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Withdrawal{}
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.UserID,
			&i.Asset,
			&i.Amount,
			&i.DestinationAddr,
			&i.Network,
			&i.Status,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ErrorMessage,
			&i.TxHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ProcessingVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWithdrawalByID = `-- name: GetWithdrawalByID :one
SELECT id, idempotency_key, user_id, asset, amount, destination_addr, network, status, retry_count, max_retries, error_message, tx_hash, created_at, updated_at, processed_at, processing_version FROM withdrawals WHERE id = $1
`

func (q *Queries) GetWithdrawalByID(ctx context.Context, id string) (Withdrawal, error) {
	row := q.db.QueryRow(ctx, getWithdrawalByID, id)
	var i Withdrawal
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.UserID,
		&i.Asset,
		&i.Amount,
		&i.DestinationAddr,
		&i.Network,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.TxHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.ProcessingVersion,
	)
	return i, err
}

const getWithdrawalByIdempotencyKey = `-- name: GetWithdrawalByIdempotencyKey :one
SELECT id, idempotency_key, user_id, asset, amount, destination_addr, network, status, retry_count, max_retries, error_message, tx_hash, created_at, updated_at, processed_at, processing_version FROM withdrawals WHERE idempotency_key = $1
`

func (q *Queries) GetWithdrawalByIdempotencyKey(ctx context.Context, idempotencyKey string) (Withdrawal, error) {
	row := q.db.QueryRow(ctx, getWithdrawalByIdempotencyKey, idempotencyKey)
	var i Withdrawal
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.UserID,
		&i.Asset,
		&i.Amount,
		&i.DestinationAddr,
		&i.Network,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.TxHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.ProcessingVersion,
	)
	return i, err
}

const listWithdrawalsByStatus = `-- name: ListWithdrawalsByStatus :many
SELECT id, idempotency_key, user_id, asset, amount, destination_addr, network, status, retry_count, max_retries, error_message, tx_hash, created_at, updated_at, processed_at, processing_version FROM withdrawals WHERE status = $1 ORDER BY created_at ASC LIMIT $2
`

type ListWithdrawalsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) ListWithdrawalsByStatus(ctx context.Context, arg ListWithdrawalsByStatusParams) ([]Withdrawal, error) {
	rows, err := q.db.Query(ctx, listWithdrawalsByStatus, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Withdrawal{}
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.UserID,
			&i.Asset,
			&i.Amount,
			&i.DestinationAddr,
			&i.Network,
			&i.Status,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ErrorMessage,
			&i.TxHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ProcessingVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWithdrawalsByUserID = `-- name: ListWithdrawalsByUserID :many
SELECT id, idempotency_key, user_id, asset, amount, destination_addr, network, status, retry_count, max_retries, error_message, tx_hash, created_at, updated_at, processed_at, processing_version FROM withdrawals WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListWithdrawalsByUserIDParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListWithdrawalsByUserID(ctx context.Context, arg ListWithdrawalsByUserIDParams) ([]Withdrawal, error) {
	rows, err := q.db.Query(ctx, listWithdrawalsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Withdrawal{}
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.UserID,
			&i.Asset,
			&i.Amount,
			&i.DestinationAddr,
			&i.Network,
			&i.Status,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ErrorMessage,
			&i.TxHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ProcessingVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWithdrawal = `-- name: UpdateWithdrawal :one
UPDATE withdrawals SET
    status = $2,
    retry_count = $3,
    error_message = $4,
    tx_hash = $5,
    updated_at = $6,
    processed_at = $7,
    processing_version = processing_version + 1
WHERE id = $1
RETURNING id, idempotency_key, user_id, asset, amount, destination_addr, network, status, retry_count, max_retries, error_message, tx_hash, created_at, updated_at, processed_at, processing_version
`

type UpdateWithdrawalParams struct {
	ID           string             `json:"id"`
	Status       string             `json:"status"`
	RetryCount   int32              `json:"retry_count"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	TxHash       pgtype.Text        `json:"tx_hash"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt  pgtype.Timestamptz `json:"processed_at"`
}

func (q *Queries) UpdateWithdrawal(ctx context.Context, arg UpdateWithdrawalParams) (Withdrawal, error) {
	row := q.db.QueryRow(ctx, updateWithdrawal,
		arg.ID,
		arg.Status,
		arg.RetryCount,
		arg.ErrorMessage,
		arg.TxHash,
		arg.UpdatedAt,
		arg.ProcessedAt,
	)
	var i Withdrawal
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.UserID,
		&i.Asset,
		&i.Amount,
		&i.DestinationAddr,
		&i.Network,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.TxHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.ProcessingVersion,
	)
	return i, err
}

const updateWithdrawalWithVersion = `-- name: UpdateWithdrawalWithVersion :one
UPDATE withdrawals SET
    status = $2,
    retry_count = $3,
    error_message = $4,
    tx_hash = $5,
    updated_at = $6,
    processed_at = $7,
    processing_version = processing_version + 1
WHERE id = $1 AND processing_version = $8
RETURNING id, idempotency_key, user_id, asset, amount, destination_addr, network, status, retry_count, max_retries, error_message, tx_hash, created_at, updated_at, processed_at, processing_version
`

type UpdateWithdrawalWithVersionParams struct {
	ID                string             `json:"id"`
	Status            string             `json:"status"`
	RetryCount        int32              `json:"retry_count"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	TxHash            pgtype.Text        `json:"tx_hash"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt       pgtype.Timestamptz `json:"processed_at"`
	ProcessingVersion int64              `json:"processing_version"`
}

func (q *Queries) UpdateWithdrawalWithVersion(ctx context.Context, arg UpdateWithdrawalWithVersionParams) (Withdrawal, error) {
	row := q.db.QueryRow(ctx, updateWithdrawalWithVersion,
		arg.ID,
		arg.Status,
		arg.RetryCount,
		arg.ErrorMessage,
		arg.TxHash,
		arg.UpdatedAt,
		arg.ProcessedAt,
		arg.ProcessingVersion,
	)
	var i Withdrawal
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.UserID,
		&i.Asset,
		&i.Amount,
		&i.DestinationAddr,
		&i.Network,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.TxHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.ProcessingVersion,
	)
	return i, err
}
